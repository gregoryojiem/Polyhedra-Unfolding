@page "/"

<PageTitle>Unfolding</PageTitle>

<title>Polyhedra Unfolding</title>

<header>
    <h1>Polyhedra Unfolding</h1>
    <p>Designing efficient edge-unfolding algorithms</p>
</header>

<main>
    <section id="problem-description">
        <h2>TOPP Problem 9: Edge-Unfolding Convex Polyhedra</h2>
        <div class="problem-statement">
            Can every convex polyhedron be cut along its edges and unfolded flat to a single, nonoverlapping, simple polygon?
        </div>

        <div class="origin">
            An explanation of the problem.
        </div>
    </section>

    <section id="our-approach">
        <h2>Our Approach</h2>
        <p>
            Filler text
        </p>
    </section>


    <section class="bibliography">
        <h2>Bibliography</h2>
        <dl>
            <dt>[BDE+03]</dt>
            <dd>Marshall Bern, Erik D. Demaine, David Eppstein, Eric Kuo, Andrea Mantler, and Jack Snoeyink. Ununfoldable polyhedra with convex faces. Comput. Geom. Theory Appl., 24(2):51–62, 2003.</dd>

            <dt>[Dür25]</dt>
            <dd>Albrecht Dürer. The painter’s manual: A manual of measurement of lines, areas, and solids by means of compass and ruler assembled by Albrecht Dürer for the use of all lovers of art with appropriate illustrations arranged to be printed in the year MDXXV. New York: Abaris Books, 1977, 1525. English translation by Walter L. Strauss of ‘Unterweysung der Messung mit dem Zirkel un Richtscheyt in Linien Ebnen uhnd Gantzen Corporen’.</dd>

            <dt>[MO01]</dt>
            <dd>J. S. B. Mitchell and Joseph O’Rourke. Computational geometry column 42. Internat. J. Comput. Geom. Appl., 11(5):573–582, 2001. Also in SIGACT News 32(3):63-72 (2001), Issue 120.</dd>

            <dt>[O'R00]</dt>
            <dd>Joseph O’Rourke. Folding and unfolding in computational geometry. In Proc. 1998 Japan Conf. Discrete Comput. Geom., volume 1763 of Lecture Notes Comput. Sci., pages 258–266. Springer-Verlag, 2000.</dd>

            <dt>[She75]</dt>
            <dd>Geoffrey C. Shephard. Convex polytopes with convex nets. Math. Proc. Camb. Phil. Soc., 78:389–403, 1975.</dd>
        </dl>
    </section>
</main>

<script type="module" src="renderer.js"></script>

<br />
<br />

<div id="visualization">
    <h3>Interactive Demo</h3>
    <div class="dropdown">
        <button class="drop-btn" @onclick="ToggleDropdown">Shapes ▼</button>
        @if (displayDropdown)
        {
            <div class="dropdown-content">
                @foreach (var shapeName in shapeNames)
                {
                    <a @onclick="@(async () => { await OnSelectedShapeClick(shapeName); ToggleDropdown(); })">
                        @shapeName
                    </a>
                }
            </div>
        }
    </div>

    @if (MainPageViewModel.currentView == "3D")
    {
        <div>
            <button @onclick="OnFlattenClick">See flattened polyhedra</button>
            <button @onclick="OnSwapViewClick">Swap to 2D view</button>
            @*<button @onclick="OnUnfoldClick">View unfolding</button>*@
        </div>
    }

    else if (MainPageViewModel.currentView == "2D")
    {
        <div>
            <button @onclick="OnStepButtonClick">Step through algorithm</button>
            <button @onclick="OnUndoButtonClick">Undo step</button>
            <button @onclick="OnCompleteButtonClick">Unfold completely</button>
            <button @onclick="OnResetButtonClick">Reset</button>
            <button @onclick="OnUnplacedButtonClick">Unplaced polygon visibility</button>
            <button @onclick="OnSwapViewClick">Swap to 3D view</button>
        </div>
    }
</div>

@inject IJSRuntime JSRuntime
@using Polyhedra

@code {
    private bool displayDropdown = false;
    private List<string> shapeNames = PolyhedronLibrary.GetShapeNames();

    protected override async Task OnAfterRenderAsync(bool begunRender)
    {
        if (!begunRender)
        {
            return;
        }

        while (await JSRuntime.InvokeAsync<bool>("eval", "typeof handleRendering3D === 'undefined'"))
        {
            await Task.Delay(100);
        }

        var currentView = MainPageViewModel.currentView;

        if (MainPageViewModel.DoUnfoldAnimation)
        {
            var polyhedronJSON = MainPageViewModel.GetDisplayPolyhedronJSON();
            var polygonNetJSON = MainPageViewModel.GetDisplayNetJSON();
            await JSRuntime.InvokeVoidAsync("handleUnfoldAnimation", polyhedronJSON, polygonNetJSON);
        }
        else if (currentView == "2D")
        {
            var polygonNetJSON = MainPageViewModel.GetDisplayNetJSON();
            await JSRuntime.InvokeVoidAsync("handleRendering2D", polygonNetJSON);
        }
        else if (currentView == "3D")
        {
            var polyhedronJSON = MainPageViewModel.GetDisplayPolyhedronJSON();
            await JSRuntime.InvokeVoidAsync("handleRendering3D", polyhedronJSON);
        }

        StateHasChanged();
    }

    private async Task OnFlattenClick()
    {
        MainPageViewModel.FlattenToggle();
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private async Task OnSwapViewClick()
    {
        MainPageViewModel.SwapView();
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private async Task OnUnfoldClick()
    {
        MainPageViewModel.UnfoldAnimation();
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private async Task OnStepButtonClick()
    {
        MainPageViewModel.PerformStep();
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private async Task OnUndoButtonClick()
    {
        MainPageViewModel.UndoStep();
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private async Task OnCompleteButtonClick()
    {
        MainPageViewModel.CompleteStep();
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private async Task OnResetButtonClick()
    {
        MainPageViewModel.ResetStep();
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private async Task OnUnplacedButtonClick()
    {
        MainPageViewModel.UnplacedVisibilityToggle();
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private async Task OnSelectedShapeClick(string polyhedra)
    {
        MainPageViewModel.SelectPolyhedra(polyhedra);
        await OnAfterRenderAsync(true);
        StateHasChanged();
    }

    private void ToggleDropdown()
    {
        Console.WriteLine("toggling dropdown");
        displayDropdown = !displayDropdown;
        StateHasChanged();
    }
}
